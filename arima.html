
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>London Daily Max Temp — ARIMA forecast (CDN-only, ESM)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --fg:#111; --muted:#666; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; color: var(--fg); }
    h1 { margin: 0 0 .5rem; }
    p.muted { color: var(--muted); margin-top: .25rem; }
    #status { color: var(--muted); margin:.5rem 0 0; }
    #chart { border: 1px solid #ddd; display:block; margin-top: 1rem; } /* fixed frame */
    pre { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:flex; gap:1rem; flex-wrap:wrap; align-items:baseline; margin-top:.75rem; }
    .pill { background:#f2f2f2; padding:.25rem .5rem; border-radius:.5rem; }
    a { color:#0645ad; text-decoration: none; }
  </style>
</head>
<body>
  <h1>London daily max temperature — ARIMA forecast (next 365 days)</h1>
  <p class="muted">
    Source: Open‑Meteo Climate API (51.5°N, −0.13°E), daily <code>temperature_2m_max</code>, 1950‑01‑01 → 2024‑12‑31.
    Forecast is statistical (ARIMA) and uses climate‑modelled data, not direct observations. No API key required. 
  </p>

  <div class="row">
    <span class="pill">Model: ARIMA(2,1,2)</span>
    <span class="pill">Horizon: 365 days</span>
    <span class="pill" id="range"></span>
  </div>

  <p id="status">Loading…</p>
  <canvas id="chart" width="800" height="400"></canvas>
  <pre id="out"></pre>

  <script type="module">
    // Import ESM bundles directly from CDN (no globals, no bundler).
    import Chart from 'https://esm.sh/chart.js@4.5.0/auto';
    import ARIMAPromise from 'https://esm.sh/arima@0.2.5/async';

    // ---- Config ----
    const API_URL = 'https://climate-api.open-meteo.com/v1/climate?latitude=51.5&longitude=-0.13&start_date=1950-01-01&end_date=2024-12-31&daily=temperature_2m_max';

    const statusEl = document.getElementById('status');
    const outEl    = document.getElementById('out');
    const rangeEl  = document.getElementById('range');
    const canvas   = document.getElementById('chart');
    let chart;

    // ---- Utilities ----
    const toDate = s => new Date(s + 'T00:00:00Z');
    function formatISO(d) { return d.toISOString().slice(0,10); } // YYYY-MM-DD
    function addDays(d, n) { const x = new Date(d); x.setUTCDate(x.getUTCDate() + n); return x; }
    function labelsFrom(startDate, n) {
      return Array.from({length: n}, (_, i) => formatISO(addDays(startDate, i)));
    }
    const pad = (arr, n, fill=null) => { const out = arr.slice(); while (out.length < n) out.push(fill); return out; };

    // ---- Draw (fixed-size canvas; Chart.js won't resize it) ----
    function drawHistory(dates, series) {
      chart?.destroy();
      chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: dates,
          datasets: [{ label: 'Daily max temp (°C) — history', data: series, borderColor: '#1f77b4', tension: .2, pointRadius: 0 }]
        },
        options: {
          responsive: false, // respect 800x400 canvas size
          plugins: { legend: { position: 'bottom' } },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { ticks: { maxTicksLimit: 10 }, title: { display: true, text: 'Date (UTC)' } },
            y: { title: { display: true, text: '°C' } }
          }
        }
      });
    }

    function overlayForecast(historyDates, history, fc, se) {
      const n = history.length, h = fc.length, N = n + h;
      const lastDate = toDate(historyDates[historyDates.length - 1]);
      const fcDates  = labelsFrom(addDays(lastDate, 1), h);
      const labels   = historyDates.concat(fcDates);

      const hist   = pad(history, N, null);
      const fcLine = pad(Array(n).fill(null).concat(fc), N, null);
      const upper  = pad(Array(n).fill(null).concat(fc.map((y,i)=> y + se[i])), N, null);
      const lower  = pad(Array(n).fill(null).concat(fc.map((y,i)=> y - se[i])), N, null);

      chart.data.labels = labels;
      chart.data.datasets = [
        { label: 'Daily max temp (°C) — history', data: hist,  borderColor: '#1f77b4', tension: .2, pointRadius: 0, spanGaps: true },
        { label: 'Forecast (mean)',              data: fcLine, borderColor: '#ff7f0e', borderDash: [6,4], tension: .2, pointRadius: 0, spanGaps: true },
        { label: '+1σ',                          data: upper,  borderColor: '#ffbb78', pointRadius: 0, borderWidth: 1, spanGaps: true },
        { label: '-1σ',                          data: lower,  borderColor: '#ffbb78', pointRadius: 0, borderWidth: 1, spanGaps: true }
      ];
      chart.update();
    }

    async function main() {
      try {
        statusEl.textContent = 'Fetching climate data…';
        const res = await fetch(API_URL, { headers: { 'Accept': 'application/json' }});
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const js = await res.json();

        // Expect structure like: { daily: { time: [...], temperature_2m_max: [...] } }
        const dates = js?.daily?.time;
        const tmax  = js?.daily?.temperature_2m_max;
        if (!Array.isArray(dates) || !Array.isArray(tmax) || dates.length !== tmax.length) {
          throw new Error('Unexpected API shape for daily data');
        }

        // Show available range
        rangeEl.textContent = `Data: ${dates[0]} → ${dates[dates.length - 1]} (${dates.length} days)`;

        // Draw history now, so the page shows something while ARIMA compiles
        drawHistory(dates, tmax);
        statusEl.textContent = 'Compiling ARIMA (WASM) and training…';

        // Load ARIMA (async WASM loader) and fit model
        const ARIMA = await ARIMAPromise;  // resolves to the ARIMA class
        const model = new ARIMA({ p: 2, d: 1, q: 2, P: 0, D: 0, Q: 0, s: 365, verbose: false }).train(tmax);

        // Forecast next 365 days
        statusEl.textContent = 'Forecasting next 365 days…';
        const horizon = 365;
        const [pred, stderr] = model.predict(horizon);

        // Output summary & overlay forecast
        const firstFcDate = formatISO(addDays(toDate(dates[dates.length - 1]), 1));
        const lastFcDate  = formatISO(addDays(toDate(dates[dates.length - 1]), horizon));
        outEl.textContent =
          `Forecast window: ${firstFcDate} → ${lastFcDate}\n` +
          `Mean of first 7 forecast days: ${pred.slice(0,7).map(x=>x.toFixed(2)).join(', ')} °C\n` +
          `Mean of last 7 forecast days:  ${pred.slice(-7).map(x=>x.toFixed(2)).join(', ')} °C`;

        overlayForecast(dates, tmax, pred, stderr);
        statusEl.textContent = 'Done.';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error: ' + (err?.message || err);
      }
    }

    main();
  </script>
</body>
</html>
